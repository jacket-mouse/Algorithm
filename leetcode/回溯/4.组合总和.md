# 组合总和

https://leetcode.cn/problems/combination-sum/description/

- 组合没有数量要求
- 元素可无限重复选取

```c++
class Solution {
private:
    vector<vector<int>> ans;
    vector<int> path;
    int sum;
    void backtracing(int target, vector<int>& candidates){
        if(sum == target){
            ans.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = 0; i < candidates.size(); i++){
            if(!path.empty() && candidates[i] < path.back()) continue; // 之后选的数不能比之前选过的小，防止重复
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracing(target, candidates);
            path.pop_back();
            sum -= candidates[i];
        }

    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        sum = 0;
        backtracing(target, candidates);
        return ans;
    }
};
```

代码随想录代码：

1. 使用`startIndex`取代了我的对于`path`数组的判断
2. `sum`不作为全局变量，而是作为了函数参数

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // 需要排序
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```



```c
int* path;
int pathTop;
int** ans;
int ansTop;
//记录每一个和等于target的path数组长度
int* length;

void backTracking(int target, int index, int* candidates, int candidatesSize, int sum) {
    //若sum>=target就应该终止遍历
    if(sum >= target) {
        //若sum等于target，将当前的组合放入ans数组中
        if(sum == target) {
            int* tempPath = (int*)malloc(sizeof(int) * pathTop);
            int j;
            for(j = 0; j < pathTop; j++) {
                tempPath[j] = path[j];
            }
            ans[ansTop] = tempPath;
            length[ansTop++] = pathTop;
        }
        return ;
    }

    int i;
    for(i = index; i < candidatesSize; i++) {
        //将当前数字大小加入sum
        sum+=candidates[i];
        path[pathTop++] = candidates[i];
        backTracking(target, i, candidates, candidatesSize, sum);
        sum-=candidates[i];
        pathTop--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    //初始化变量
    path = (int*)malloc(sizeof(int) * 50);
    ans = (int**)malloc(sizeof(int*) * 200);
    length = (int*)malloc(sizeof(int) * 200);
    ansTop = pathTop = 0;
    backTracking(target, 0, candidates, candidatesSize, 0);

    //设置返回的数组大小
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```

