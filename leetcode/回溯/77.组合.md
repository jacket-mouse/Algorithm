# 77.组合

https://leetcode.cn/problems/combinations/description/

```c++
class Solution {
private:
    vector<vector<int>> ans; // 最终结果
    vector<int> path; // 临时路径
    void backtracking(int n, int k, int start){
        if(path.size() == k){ // 路径长度等于k
            ans.push_back(path);
            return;
        }
        for(int i = start; i <= n; i++){
            path.push_back(i); 
            backtracking(n, k, i+1);
            path.pop_back(); 
        }
    }
    
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return ans;
    }
};
```

剪枝优化：

![77.组合4](assets/组合优化.png)

```c++
for(int i = start; i <= n; i++){
  path.push_back(i); 
  backtracking(n, k, i+1);
  path.pop_back(); 
}
```

此处的`i<=n`可以优化：

`n-i+1 >= k-path.size()`当前剩余的可选集合大小+1（==为什么加 1？根据上图具体算一算==） 应当大于等于所需要的元素个数，化简后`i <= n-k+path.size()+1`

```c++
for(int i = start; i <= n-k+path.size()+1; i++){
  path.push_back(i); 
  backtracking(n, k, i+1);
  path.pop_back(); 
}
```



```c
int* path;
int pathTop;
int** ans;
int ansTop;

void backtracking(int n, int k,int startIndex) {
    //当path中元素个数为k个时，我们需要将path数组放入ans二维数组中
    if(pathTop == k) {
        //path数组为我们动态申请，若直接将其地址放入二维数组，path数组中的值会随着我们回溯而逐渐变化
        //因此创建新的数组存储path中的值
        int* temp = (int*)malloc(sizeof(int) * k);
        int i;
        for(i = 0; i < k; i++) {
            temp[i] = path[i];
        }
        ans[ansTop++] = temp;
        return ;
    }

    int j;
    for(j = startIndex; j <=n ;j++) {
        //将当前结点放入path数组
        path[pathTop++] = j;
        //进行递归
        backtracking(n, k, j + 1);
        //进行回溯，将数组最上层结点弹出
        pathTop--;
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    //path数组存储符合条件的结果
    path = (int*)malloc(sizeof(int) * k);
    //ans二维数组存储符合条件的结果数组的集合。（数组足够大，避免极端情况）
    ans = (int**)malloc(sizeof(int*) * 10000);
    pathTop = ansTop = 0;

    //回溯算法
    backtracking(n, k, 1);
    //最后的返回大小为ans数组大小
    *returnSize = ansTop;
    //returnColumnSizes数组存储ans二维数组对应下标中一维数组的长度（都为k）
    *returnColumnSizes = (int*)malloc(sizeof(int) *(*returnSize));
    int i;
    for(i = 0; i < *returnSize; i++) {
        (*returnColumnSizes)[i] = k;
    }
    //返回ans二维数组
    return ans;
}
```

